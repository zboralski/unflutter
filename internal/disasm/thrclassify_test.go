package disasm

import (
	"os"
	"path/filepath"
	"testing"
)

// fixtureDir returns the path to thr_audit fixture JSONL files.
// These are generated by `go run ./cmd/unflutter thr-audit` on the three samples.
func fixtureDir() string {
	// Walk up from test dir to find scratch/thr_audit/
	dir, _ := os.Getwd()
	for {
		candidate := filepath.Join(dir, "scratch", "thr_audit")
		if fi, err := os.Stat(candidate); err == nil && fi.IsDir() {
			return candidate
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			return ""
		}
		dir = parent
	}
}

type fixtureSpec struct {
	name    string
	jsonl   string
	version string

	// Expected classification counts.
	wantTotal              int
	wantRuntimeEntrypoint  int
	wantObjectStoreCache   int
	wantIsolateGroupPtr    int
	wantUnknown            int
	wantBandsMax           int // band count must not exceed this
	want100PctRuntimeEntry bool
}

var fixtures = []fixtureSpec{
	{
		name:                   "evil",
		jsonl:                  "evil_thr_loads.jsonl",
		version:                "3.10.7",
		wantTotal:              110,
		wantRuntimeEntrypoint:  91,
		wantObjectStoreCache:   14,
		wantIsolateGroupPtr:    5,
		wantUnknown:            0,
		wantBandsMax:           11, // currently 9, allow +2
		want100PctRuntimeEntry: false,
	},
	{
		name:                   "newandromo",
		jsonl:                  "newandromo_thr_loads.jsonl",
		version:                "3.1.0",
		wantTotal:              194,
		wantRuntimeEntrypoint:  143,
		wantObjectStoreCache:   6,
		wantIsolateGroupPtr:    45,
		wantUnknown:            0,
		wantBandsMax:           14, // currently 12, allow +2
		want100PctRuntimeEntry: false,
	},
	{
		name:                   "blutter",
		jsonl:                  "blutter_thr_loads.jsonl",
		version:                "2.17.6",
		wantTotal:              148,
		wantRuntimeEntrypoint:  148,
		wantObjectStoreCache:   0,
		wantIsolateGroupPtr:    0,
		wantUnknown:            0,
		wantBandsMax:           10, // currently 8, allow +2
		want100PctRuntimeEntry: true,
	},
}

func TestClassifyRegression(t *testing.T) {
	dir := fixtureDir()
	if dir == "" {
		t.Skip("scratch/thr_audit/ not found â€” run thr-audit first")
	}

	for _, fx := range fixtures {
		t.Run(fx.name, func(t *testing.T) {
			path := filepath.Join(dir, fx.jsonl)
			f, err := os.Open(path)
			if err != nil {
				t.Skipf("fixture not found: %v", err)
			}
			defer f.Close()

			records, err := ReadAuditRecords(f)
			if err != nil {
				t.Fatalf("read records: %v", err)
			}

			bands := ClusterBands(records, 0x18)
			classified := ClassifyRecords(records, bands)
			summary := Summarize(classified)

			// Gate: UNKNOWN must be 0.
			if got := summary.Counts[ClassUnknown]; got != fx.wantUnknown {
				t.Errorf("UNKNOWN = %d, want %d", got, fx.wantUnknown)
			}

			// Gate: total unresolved must match.
			if summary.Total != fx.wantTotal {
				t.Errorf("total = %d, want %d", summary.Total, fx.wantTotal)
			}

			// Gate: class counts must match exactly.
			if got := summary.Counts[ClassRuntimeEntrypoint]; got != fx.wantRuntimeEntrypoint {
				t.Errorf("RUNTIME_ENTRYPOINT = %d, want %d", got, fx.wantRuntimeEntrypoint)
			}
			if got := summary.Counts[ClassObjectStoreCache]; got != fx.wantObjectStoreCache {
				t.Errorf("OBJECTSTORE_OR_CACHE = %d, want %d", got, fx.wantObjectStoreCache)
			}
			if got := summary.Counts[ClassIsolateGroupPtr]; got != fx.wantIsolateGroupPtr {
				t.Errorf("ISOLATE_OR_GROUP_PTR = %d, want %d", got, fx.wantIsolateGroupPtr)
			}

			// Gate: blutter must be 100% RUNTIME_ENTRYPOINT.
			if fx.want100PctRuntimeEntry {
				if summary.Counts[ClassRuntimeEntrypoint] != summary.Total {
					t.Errorf("expected 100%% RUNTIME_ENTRYPOINT, got %d/%d",
						summary.Counts[ClassRuntimeEntrypoint], summary.Total)
				}
			}

			// Gate: band count must not increase beyond threshold.
			if len(bands.Bands) > fx.wantBandsMax {
				t.Errorf("band count = %d, exceeds max %d", len(bands.Bands), fx.wantBandsMax)
			}
		})
	}
}
